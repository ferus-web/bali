# Bali Manual
This manual is largely inspired by Monoucha's manual. \
**WARNING**: Bali is only tested with the default memory management strategy (ORC). It _should_ work with others, but they aren't tested. You are on your own if you use them. \
**WARNING**: If you embed Bali in your program, you must compile it with the C++ backend as Bali relies on some C++ libraries.

**This manual is largely under construction. Report problems if you can.**

# Table of Contents
* [Introduction](#introduction)
    - [Terms to learn](#terms-to-learn)
        - [Atom](#atom)
    - [Baby's first scripts](#babys-first-scripts)
* [Creating new types](#creating-new-types)
    - [Wrapping primitives](#wrapping-primitives)
    - [Wrapping our type](#wrapping-our-type)
    - [Modifying our type's prototype](#modifying-our-prototype)
* [Supported ECMAScript APIs](#supported-ecmascript-apis)
    - [The Math type](#the-math-type)
    - [The JSON type (Incomplete)](#the-json-type) 
    - [The URL type (Incomplete)](#the-url-type)
* [Using Balde](#using-balde)
    - [Running scripts](#running-scripts)
    - [Flags](#flags)
    - [Using the REPL](#using-the-repl)
    - [Experiments](#experiments)

# Introduction
Bali is a JavaScript engine written from scratch in Nim for the [Ferus web engine](https://github.com/ferus-web/ferus). It is designed to be convenient to interface with whilst being fast and compliant. It provides you high-level abstractions as far as humanly possible.

Bali is evolving very quickly, and as such, the API is subject to breaking. Such changes will be generally marked by a bump in the minor version.

## Terms to learn
Although not evident at first, learning these terms will make things much easier for you.

### Atom
An atom is a variant type discriminated by its `kind` field that can be:
- An integer (signed)
- An integer (unsigned)
- A float (64-bit)
- A string
- A sequence (of more atoms, but you can mark it as homogenous to restrict it to one type)
- An object (basically, an overglorified hashmap)
There's also an identifier type, but that's only internally used by Mirage.

## Baby's First Scripts
Now, we'll learn how to write a Nim program that can load and evaluate JavaScript. You'll need to implement two of Bali's components:
- The `grammar` module, which as the name suggests, is responsible for lexing and parsing the JavaScript source code into an abstract syntax tree
- The `runtime` module, which takes in the AST and converts it into bytecode that targets the [Mirage/Pulsar](https://github.com/ferus-web/mirage) interpreter.

However, all of the complexities are neatly abstracted away, so you needn't worry about all of that. The API is deceptively simple. \
Here's the minimal example.
```nim
import bali/grammar/prelude
import bali/runtime/prelude

# Create a parser.
let parser = newParser("""
console.log("Hello from JavaScript!")
""")

# Parse the source code into an AST.
let ast = parser.parse()

# Instantiate the runtime, which generates the bytecode and runs it.
# You can optionally pass on a filename, it only exists to keep the
# bytecode caching mechanism work.
let runtime = newRuntime("nameofyourfile.js", ast)

# Begin execution. This halts your code until execution is completed.
runtime.run()
```
Let's breakdown what each line does:
- We're creating a parser with `newParser()` and feeding it our source code.
- We're parsing the source code into an abstract syntax tree.
- We're feeding the AST to the runtime.
- We're running the generated bytecode.

That's it! You just executed JavaScript with Bali! Yay.


# Creating new types
Now, let us learn how to create new types. Bali can automatically "wrap" a Nim object into its representative atom.
Bali can do this for primitives like integers, floats, strings and sequences of said primitives as well.

## Wrapping Primitives
Let us try wrapping some primitives into atoms before wrapping a Nim object.
```nim
import std/options
import bali/runtime/prelude

let name = "John Doe"
let age = 24'u
let likes = @["Skating", "Tennis", "Programming"]

let aName = wrap(name)
let aAge = wrap(age)
let aLikes = wrap(likes)

assert aName.kind == String
assert aAge.kind == UnsignedInt
assert aLikes.kind == Sequence

assert aName.isSome and aName.getStr().get() == name
assert aAge.isSome and aAge.getUint().get() == age
```
Here, we just turned Nim types into atoms, which can be of any type, only dictated by their `kind` field. We can also turn the first two atoms back into their original representation. \
Unfortunately, it isn't as simple for the sequence, which can be dynamically typed with heterogenous types at this point. \
The `getXXX` functions return `Option[requested type]` as they need to safely provide a way to tell if an atom can be of the requested primitive type. 

### Hold up, this isn't how JavaScript engines work!
Yep, they use coercion. You _could_ implement coercion like this using the exception system, but Bali already handles some of the coercion functions that ECMAScript expects. They'll be covered later.

## Wrapping our type
Assuming you already have the runtime set up via `newRuntime()`, you can define types before `run()` is called.

```nim
type Person* = object
  name*: string
  age*: uint
  likes*: seq[string]

runtime.registerType(prototype = Person, name = "Person")
runtime.setProperty(Person, "name", str("John Doe"))
runtime.setProperty(Person, "age", uinteger(24'u))
runtime.setProperty(Person, "likes", sequence(@[
  str("Skating"),
  str("Tennis"),
  str("Programming")
]))
```
Here, we're exposing our `Person` type to the JavaScript environment by specifying what fields it has, and also setting those fields. \
Now, you can easily just run this in your JS code:
```js
console.log(Person.name) // Log: John Doe
console.log(Person.age) // Log: 24
console.log(Person.likes) // Log: [Skating, Tennis, Programming]
```

## Modifying our prototype
Now, what if you wanted to add a function that can be called by every instance of your type? \
In order to do that, you need to modify its **prototype**. Assume that we want multiple instances of the previously defined `Person` class to be possible. \
We need to define a constructor for it.

```nim
runtime.defineConstructor(
    "Person",
    proc =
      let
        name = runtime.ToString(&runtime.argument(1), required = true, message = "Expected `name` argument at pos 1, got {nargs}")
        age = runtime.ToNumber(&runtime.argument(2), required = true, message = "Expected `age` argument at pos 2, got {nargs}")
      
      let person = Person(name: name, age: age.uint)

      ret person
)
```
Now, we can call `new Person("John Doe", 24)` in JavaScript land and get an instance of the `Person` class! \
Let us assume you want a `greet` function for all `Person`(s) that returns "<name> greets you back.". We can implement it like this.
```nim
runtime.definePrototypeFn(
    Person,
    "greet",
    proc(value: MAtom) =
      let 
        name = runtime.ToString(value["name"])
        age = runtime.ToNumber(value["age"])

      echo name & " greets you back."
)
```
Let us break that down, shall we?

- `definePrototypeFn`, as the name suggests, sets up a function for a type's prototype. This prototype is copied to all of the instances of that type, and all of the child classes that derive from this one, and so on and so forth.
- You might be wondering what `value` here is. It's actually the `Person` type we called `ret` on to pass it over to JS-land. It's now in the form of an atom, and unfortunately there's no way to easily turn it back into its original representation, atleast right now.

Now, the following code should work fine:
```js
let john = new Person("John Doe", 23)
let jane = new Person("Jane Doe", 28)

john.greet()
jane.greet()
```

# Supported ECMAScript APIs
Bali supports the following ECMAScript APIs.

## The Math Type
The `Math` type contains the following methods.

### `Math.random`
This function uses the global RNG instance created via [librng](https://github.com/xTrayambak/librng) to generate a float between 0 and 1.
**WARNING**: Do _NOT_ use this function in places like cryptography! All of the PRNG algorithms used are highly predictable!

#### Using another RNG algorithm
You can pass the following values as arguments for `--define:BaliRNGAlgorithm`:
- `xoroshiro128`: Xoroshiro128
- `xoroshiro128pp`: Xoroshiro128++
- `xoroshiro128ss`: Xoroshiro128**
- `mersenne_twister`: Mersenne Twister
- `marsaglia`: Marsaglia 69069
- `pcg`: PCG
- `lehmer`: Lehmer64
- `splitmix`: Splitmix64

All of them vary in terms of quality, footprint and speed. Bali defaults to `xoroshiro128` as it provides a nice balance between all of those.

### The rest of the functions
All of the functions apart from `Math.hypot` have been implemented.

# Using Balde
Balde, short for "**Bal**i **de**bugger" is a CLI tool that acts both as a script runner and a REPL.

## Running Scripts
Running a JavaScript source file is as simple as:
```command
$ balde path/to/your/file.js
```

## Flags
Balde supports a few flags for easier debugging.

### `--dump-ast`
This flag lets the runtime evaluate the AST for any errors, but does not allow for its execution. Instead, it prints out the AST instead. \
This allows for semantic errors to be thrown out. If you want an immediate AST dump, use `--dump-no-eval`.
```command
$ balde path/to/your/file.js --dump-ast
<AST representation>
```

### `--dump-no-eval`
This flag dumps the parsed representation (or AST) of the provided JavaScript source without any further evaluation. It also includes the parsing errors.
```command
$ balde path/to/your/file.js --dump-no-eval
<AST representation>
```

### `--verbose`
This flag allows all debug logs to be shown, which can be used to diagnose bugs in the engine's multiple phases (tokenization, parsing, bytecode generation and runtime). \
Beware that this gets very spammy.
```command
$ balde path/to/your/file.js --verbose
<A boat load of logs>
```

### `--dump-tokens`
This flag dumps all of the tokens of a JavaScript source file.
```command
$ balde path/to/your/file.js --dump-tokens
```

## Using the REPL
**WARNING**: The REPL is still a very unstable feature. It is known to have several bugs. \
To run the REPL, simply run Balde with no arguments.

## Experiments
Experiments are unstable Bali features that are locked behind an interpreter flag. In order to use them, you need to use the `--enable-experiments` flag. \
`--enable-experiments` expects a syntax like this:
```
--enable-experiments:<experiment1>;<experiment2>
```

### Current Experiments
- Date Routines (internal name: `date-routines`): Provides access to some of the JavaScript `Date` API.
