# Bali Manual
This manual is largely inspired by Monoucha's manual.
**WARNING**: Bali is only tested with the default memory management strategy (ORC). It _should_ work with others, but they aren't tested. You are on your own if you use them.

**This manual is largely under construction. Report problems if you can.**

# Table of Contents
* [Introduction](#introduction)
    - [Terms to learn](#terms-to-learn)
        - [Atom](#atom)
    - [Baby's first scripts](#babys-first-scripts)
* [Creating new types](#creating-new-types)
    - [Wrapping primitives](#wrapping-primitives)
    - [Wrapping our type](#wrapping-our-type)

# Introduction
Bali is a JavaScript engine written from scratch in Nim for the [Ferus web engine](https://github.com/ferus-web/ferus). It is designed to be convenient to interface with whilst being fast and compliant. It provides you high-level abstractions as far as humanly possible.

Bali is evolving very quickly, and as such, the API is subject to breaking. Such changes will be generally marked by a bump in the minor version.

## Terms to learn
Although not evident at first, learning these terms will make things much easier for you.

### Atom
An atom is a variant type discriminated by its `kind` field that can be:
- An integer (signed)
- An integer (unsigned)
- A float (64-bit)
- A string
- A sequence (of more atoms, but you can mark it as homogenous to restrict it to one type)
- An object (basically, an overglorified hashmap)
There's also an identifier type, but that's only internally used by Mirage.

## Baby's First Scripts
Now, we'll learn how to write a Nim program that can load and evaluate JavaScript. You'll need to implement two of Bali's components:
- The `grammar` module, which as the name suggests, is responsible for lexing and parsing the JavaScript source code into an abstract syntax tree
- The `runtime` module, which takes in the AST and converts it into bytecode that targets the [Mirage/Pulsar](https://github.com/ferus-web/mirage) interpreter.

However, all of the complexities are neatly abstracted away, so you needn't worry about all of that. The API is deceptively simple. \
Here's the minimal example.
```nim
import bali/grammar/prelude
import bali/runtime/prelude

# Create a parser.
let parser = newParser("""
console.log("Hello from JavaScript!")
""")

# Parse the source code into an AST.
let ast = parser.parse()

# Instantiate the runtime, which generates the bytecode and runs it.
# You can optionally pass on a filename, it only exists to keep the
# bytecode caching mechanism work.
let runtime = newRuntime("nameofyourfile.js", ast)

# Begin execution. This halts your code until execution is completed.
runtime.run()
```
Let's breakdown what each line does:
- We're creating a parser with `newParser()` and feeding it our source code.
- We're parsing the source code into an abstract syntax tree.
- We're feeding the AST to the runtime.
- We're running the generated bytecode.

That's it! You just executed JavaScript with Bali! Yay.


# Creating new types
Now, let us learn how to create new types. Bali can automatically "wrap" a Nim object into its representative atom.
Bali can do this for primitives like integers, floats, strings and sequences of said primitives as well.

## Wrapping Primitives
Let us try wrapping some primitives into atoms before wrapping a Nim object.
```nim
import std/options
import bali/runtime/prelude

let name = "John Doe"
let age = 24'u
let likes = @["Skating", "Tennis", "Programming"]

let aName = wrap(name)
let aAge = wrap(age)
let aLikes = wrap(likes)

assert aName.kind == String
assert aAge.kind == UnsignedInt
assert aLikes.kind == Sequence

assert aName.isSome and aName.getStr().get() == name
assert aAge.isSome and aAge.getUint().get() == age
```
Here, we just turned Nim types into atoms, which can be of any type, only dictated by their `kind` field. We can also turn the first two atoms back into their original representation. \
Unfortunately, it isn't as simple for the sequence, which can be dynamically typed with heterogenous types at this point. \
The `getXXX` functions return `Option[requested type]` as they need to safely provide a way to tell if an atom can be of the requested primitive type. 

### Hold up, this isn't how JavaScript engines work!
Yep, they use coercion. You _could_ implement coercion like this using the exception system, but Bali already handles some of the coercion functions that ECMAScript expects. They'll be covered later.

## Wrapping our type
Assuming you already have the runtime set up via `newRuntime()`, you can define types before `run()` is called.

```nim
type Person* = object
  name*: string
  age*: uint
  likes*: seq[string]

runtime.registerType(prototype = Person, name = "Person")
runtime.setProperty(Person, "name", str("John Doe"))
runtime.setProperty(Person, "age", uinteger(24'u))
runtime.setProperty(Person, "likes", sequence(@[
  str("Skating"),
  str("Tennis"),
  str("Programming")
]))
```
Here, we're exposing our `Person` type to the JavaScript environment by specifying what fields it has, and also setting those fields. \
Unfortunately, for now, you have to manually wrap those fields as `setProperty` does not do it for you yet. \
Now, you can easily just run this in your JS code:
```js
console.log(Person.name) // Log: John Doe
console.log(Person.age) // Log: 24
console.log(Person.likes) // Log: [Skating, Tennis, Programming]
```
