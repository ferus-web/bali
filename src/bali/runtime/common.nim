## Common routines for the Runtime type.
##
## Copyright (C) 2025 Trayambak Rai
import std/[strutils, logging, tables, sugar]
import
  pkg/bali/runtime/[atom_helpers, atom_obj_variant, types, construction],
  pkg/bali/runtime/niche/lowering,
  pkg/bali/runtime/vm/prelude,
  pkg/bali/runtime/vm/ir/generator,
  pkg/bali/runtime/vm/heap/manager,
  pkg/bali/runtime/vm/atom,
  pkg/bali/runtime/abstract/[to_string, equating],
  pkg/bali/stdlib/prelude
import pkg/bali/grammar/prelude

proc typeRegistrationFinalizer*(runtime: Runtime) {.gcsafe.} =
  ## Called by the engine when it needs to register all types' function properties.
  for typ in runtime.types:
    let index = runtime.index(typ.name, globalIndex())
    var jsObj = obj(runtime)

    for name, value in typ.members:
      if value.isFn:
        capture name, value:
          jsObj[name] = nativeCallable(
            runtime.heapManager,
            proc() =
              value.fn()(),
          )
      else:
        jsObj[name] = value.atom()

    if typ.constructor != nil:
      let fn = nativeCallable(runtime.heapManager, typ.constructor)
      jsObj.tag("Construct", fn)
      jsObj["constructor"] = fn

    runtime.vm[].addAtom(ensureMove(jsObj), index.int)

proc registerEcmaTypes*(runtime: Runtime) =
  if runtime.registeredEcmaTypes:
    return

  runtime.registeredEcmaTypes = true
  std_string.generateStdIR(runtime)
  console.generateStdIR(runtime)
  math.generateStdIR(runtime)
  uri.generateStdIR(runtime)
  errors_ir.generateStdIR(runtime)
  base64.generateStdIR(runtime)
  json.generateStdIR(runtime)
  encodeUri.generateStdIR(runtime)

  when not defined(baliTest262FyiDisableICULinkingCode):
    date.generateStdIR(runtime)

  std_bigint.generateStdIR(runtime)
  std_number.generateStdIR(runtime)
  std_set.generateStdIR(runtime)

  parseIntGenerateStdIR(runtime)

proc run*(runtime: Runtime) {.gcsafe.} =
  ## This function starts the code generator and executes the generated bytecode.
  ## It also starts the interpreter's garbage collector. Any attempts to interact with the Bali GC
  ## prior to this function being called will result in undefined behaviour, generally an infinite loop.

  # Prior to _ANY_ possibility of allocations occurring,
  # we must instantiate the heap manager.
  runtime.vm.heapManager = runtime.heapManager
  # runtime.heapManager = runtime.vm.heapManager

  runtime.test262 = runtime.ast.test262
  runtime.registerEcmaTypes()

  runtime.allocStatsStart = getAllocStats()

  runtime.vm.useJit = runtime.opts.codegen.jitCompiler
  runtime.vm.midtier.dumpIrForFuncs = runtime.opts.jit.madhyasthalDumpIRFor

  runtime.generateInternalIR()

  if runtime.opts.test262:
    test262.generateStdIR(runtime)
    runtime.deathCallback = proc(vm: PulsarInterpreter) =
      if not vm.trace.exception.message.contains(runtime.test262.negative.`type`):
        quit(QuitSuccess)
      else:
        quit(QuitFailure)

  for ident in ["undefined", "NaN", "true", "false", "null", "Infinity"]:
    runtime.markGlobal(ident)

  runtime.generateBytecodeForScope(runtime.ast.scopes[0])

  constants.generateStdIR(runtime)

  if runtime.opts.dumpBytecode:
    echo runtime.ir.emit()
    quit(0)

  # We have to attach an "equation hook" since the VM itself has no way
  # of equating values in a standards-compliant way.
  runtime.vm.equationHook = proc(a, b: JSValue): bool {.gcsafe.} =
    runtime.isLooselyEqual(a, b)

  runtime.vm.typeErrorHook = proc() {.gcsafe.} =
    runtime.typeError("not a function")

  runtime.vm.addOpImpl = proc(a, b: JSValue): JSValue {.gcsafe.} =
    newJSString(runtime, runtime.ToString(a) & runtime.ToString(b))

  runtime.vm[].feed(runtime.ir.modules)
  runtime.typeRegistrationFinalizer()

  debug "interpreter: setting entry point to `outer`"
  runtime.vm[].setEntryPoint("outer")

  for error in runtime.ast.errors:
    runtime.syntaxError($error, if runtime.opts.test262: 0 else: 1)

  if runtime.ast.doNotEvaluate and runtime.opts.test262:
    debug "runtime: `doNotEvaluate` is set to `true` in Test262 mode - skipping execution."
    quit(0)
  debug "interpreter: passing over execution to VM - here goes nothing!"
  runtime.vm[].run()

proc newRuntime*(
    file: string,
    ast: AST = default(AST),
    opts: InterpreterOpts = default(InterpreterOpts),
    predefinedBytecode: string = "",
): Runtime {.inline.} =
  ## Instantiate the runtime by feeding it the name of the file executed and the AST, alongside the interpreter settings.
  ## If the input isn't from a file, you can set it to anything - it's primarily used for caching.
  ## The AST must be valid.
  ## You can check the options exposed to you in `InterpreterOpts` by checking its documentation.

  Runtime(
    ast: ast,
    clauses: @[],
    ir: newIRGenerator("bali"),
    vm: newPulsarInterpreter(predefinedBytecode),
    heapManager: initHeapManager(),
    opts: opts,
    predefinedBytecode: predefinedBytecode,
  )
