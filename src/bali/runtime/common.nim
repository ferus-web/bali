## Common routines for the Runtime type.
##
## Copyright (C) 2025 Trayambak Rai
import std/[strutils, logging, tables, sugar]
import
  pkg/bali/runtime/[atom_helpers, atom_obj_variant, types],
  pkg/bali/runtime/niche/lowering,
  pkg/bali/runtime/vm/prelude,
  pkg/bali/runtime/vm/ir/generator,
  pkg/bali/runtime/vm/heap/manager,
  pkg/bali/runtime/vm/atom
import pkg/bali/stdlib/prelude
import pkg/bali/grammar/prelude

proc typeRegistrationFinalizer*(runtime: Runtime) =
  ## Called by the engine when it needs to register all types' function properties.
  for typ in runtime.types:
    let index = runtime.index(typ.name, globalIndex())
    var jsObj = obj()

    for name, value in typ.members:
      if value.isFn:
        capture name, value:
          jsObj[name] = nativeCallable(
            proc() =
              value.fn()()
          )
      else:
        jsObj[name] = value.atom()

    runtime.vm[].addAtom(ensureMove(jsObj), index.int)

proc registerEcmaTypes*(runtime: Runtime) =
  if runtime.registeredEcmaTypes:
    return

  runtime.registeredEcmaTypes = true
  std_string.generateStdIR(runtime)
  console.generateStdIR(runtime)
  math.generateStdIR(runtime)
  uri.generateStdIR(runtime)
  errors_ir.generateStdIR(runtime)
  base64.generateStdIR(runtime)
  json.generateStdIR(runtime)
  encodeUri.generateStdIR(runtime)

  when not defined(baliTest262FyiDisableICULinkingCode):
    date.generateStdIR(runtime)

  std_bigint.generateStdIR(runtime)
  std_number.generateStdIR(runtime)
  std_set.generateStdIR(runtime)

  parseIntGenerateStdIR(runtime)

proc run*(runtime: Runtime) =
  ## This function starts the code generator and executes the generated bytecode.
  ## It also starts the interpreter's garbage collector. Any attempts to interact with the Bali GC
  ## prior to this function being called will result in undefined behaviour, generally an infinite loop.

  runtime.test262 = runtime.ast.test262
  runtime.registerEcmaTypes()

  runtime.allocStatsStart = getAllocStats()

  runtime.vm[].useJit = runtime.opts.codegen.jitCompiler
  runtime.vm[].midtier.dumpIrForFuncs = runtime.opts.jit.madhyasthalDumpIRFor

  runtime.generateInternalIR()

  if runtime.opts.test262:
    test262.generateStdIR(runtime)
    setDeathCallback(
      proc(vm: PulsarInterpreter, exitCode: int) =
        if not vm.trace.exception.message.contains(runtime.test262.negative.`type`):
          quit(1)
        else:
          quit(0)
    )

  for ident in ["undefined", "NaN", "true", "false", "null", "Infinity"]:
    runtime.markGlobal(ident)

  runtime.generateBytecodeForScope(runtime.ast.scopes[0])

  constants.generateStdIR(runtime)

  if runtime.opts.dumpBytecode:
    echo runtime.ir.emit()
    quit(0)

  #[ let source =
    if runtime.predefinedBytecode.len < 1:
      runtime.ir.emit()
    else:
      runtime.predefinedBytecode ]#

  runtime.vm[].feed(runtime.ir.modules)
  runtime.typeRegistrationFinalizer()

  debug "interpreter: the following bytecode will now be executed"

  #[ if not runtime.opts.dumpBytecode:
    debug source
  else:
    echo source
    quit(0) ]#

  # debug "interpreter: begin VM analyzer"
  # runtime.vm[].analyze()

  debug "interpreter: setting entry point to `outer`"
  runtime.vm[].setEntryPoint("outer")

  for error in runtime.ast.errors:
    runtime.syntaxError($error, if runtime.opts.test262: 0 else: 1)

  if runtime.ast.doNotEvaluate and runtime.opts.test262:
    debug "runtime: `doNotEvaluate` is set to `true` in Test262 mode - skipping execution."
    quit(0)
  debug "interpreter: passing over execution to VM - here goes nothing!"
  runtime.vm[].run()

proc newRuntime*(
    file: string,
    ast: AST = default(AST),
    opts: InterpreterOpts = default(InterpreterOpts),
    predefinedBytecode: string = "",
): Runtime {.inline.} =
  ## Instantiate the runtime by feeding it the name of the file executed and the AST, alongside the interpreter settings.
  ## If the input isn't from a file, you can set it to anything - it's primarily used for caching.
  ## The AST must be valid.
  ## You can check the options exposed to you in `InterpreterOpts` by checking its documentation.
  var heapManager = initHeapManager()
  setHeapManager(heapManager)

  Runtime(
    ast: ast,
    clauses: @[],
    ir: newIRGenerator("bali"),
    vm: newPulsarInterpreter(predefinedBytecode),
    opts: opts,
    predefinedBytecode: predefinedBytecode,
    heapManager: heapManager,
  )
