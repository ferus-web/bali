{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Bali","text":"<p>Bali (\u02c8b\u0251\u02d0li) is a work-in-progress JavaScript lexer, parser and interpreter written in Nim that aims to be as compliant as possible to the ECMAScript specifications.  Bali is still not in a usable state yet and is probably unstable. It is not meant to be used in production for now.</p> <p>Bali has a bytecode VM as well as two tiers of x86-64 JIT compilers (baseline and midtier). It also has a tiering mechanism in place to promote functions from the VM to the Baseline JIT to the Midtier JIT as they get hotter.</p> <p>Bali is licensed under the BSD-3 license, allowing you to freely embed it in any of your programs.</p>"},{"location":"#integrating-bali-into-your-programs","title":"Integrating Bali into your programs","text":"<p>Bali is still an alpha-quality project, but here's how you can embed Bali into your Nim programs. With it, you can: - Use JavaScript as a configuration language for your programs - Write stuff for the JS ecosystem with Nim and much, much more. (It becomes more useful as it advances!)</p> <p>For more information, check out the <code>examples/</code> directory as well as the Bali Manual.</p>"},{"location":"#usage","title":"Usage","text":"<ul> <li>Bali is integrated into the Ferus web engine and used as the JavaScript runtime's backend</li> <li>It is integrated into Basket, a fast app launcher for Wayland compositors for configuration.  Have a cool project that you use Bali in? Open a PR and add it here! :^)</li> </ul>"},{"location":"#how-compliant-is-it","title":"How compliant is it?","text":"<p>Thanks to @CanadaHonk, Bali is now on test262.fyi!  You can check how much Bali progresses/regresses by each day's run.</p>"},{"location":"#how-well-written-is-it","title":"How \"well written\" is it?","text":"<p>Bali is formatted using the nph code formatter and each commit is statically analyzed by Nimalyzer.</p> <p>It isn't indicative of the code quality, but I do put some extent into making the code slightly readable. :^)</p>"},{"location":"#how-fast-is-it","title":"How fast is it?","text":"<p>With some recent codegen optimizations, Bali is already pretty fast on cherry-picked benchmarks. Bali can perform some optimizations when it is generating code for the provided JavaScript source, granted that it can prove that there is an opportunity to optimize away things.</p> <p>It also has some rudimentary dead code elimination for some cases.</p> <p>CPU: AMD Ryzen 5 5600H (12) @ 4.28 GHz  RAM: 16 GB + 32GB swap</p>"},{"location":"#iterating-999999999-times-and-incrementing-an-integer-each-loop","title":"Iterating 999999999 times and incrementing an integer each loop","text":"<p>Bali has some loop elision optimizations in place which can fully eliminate an expensive loop when it sees the opportunity.</p> <p>NOTE: The \"JIT\" benchmark is actually misleading, because here the \"hot part\" of the code is fully removed during bytecode generation. The JIT is never triggered since there's nothing to optimize. As such, both of these benchmarks are actually just running in the interpreter. :^)</p> <p>Try it for yourself: Source code | Engine                  | Time Taken                                                     | | ----------------------- | -------------------------------------------------------------- | | Bali (Interpreter)      | 3.4ms (best case) - 7.9ms (worst case)                         | | Bali (JIT)              | 3.3ms (best case) - 5.3ms (worst case)                         |   </p>"},{"location":"#finding-a-substring-in-a-moderately-large-string","title":"Finding a substring in a moderately large string","text":"<p>Bali's string-find function (<code>String.prototype.indexOf</code>) is SIMD-accelerated, and as such, is pretty fast.</p> <p>NOTE: The \"JIT\" benchmark is actually misleading, because here the \"hot part\" of the code is fully removed during bytecode generation. The JIT is never triggered since there's nothing to optimize. As such, both of these benchmarks are actually just running in the interpreter. :^)</p> <p>Try it for yourself: Source code | Engine                     | Time Taken                                   | | -------------------------- | -------------------------------------------- | | Bali (Interpreter)         | 3.5ms (best case) - 5.8ms (worst case)       | | Bali (JIT)                 | 3.5ms (best case) - 5.5ms (worst case)       |</p>"},{"location":"#jit-triggering-microbenchmark","title":"JIT-triggering microbenchmark","text":"<p>This script is intentionally designed to make Bali's profiling mechanism catch onto it and optimize it.</p> <p>Try it for yourself: Source code | Engine                     | Time Taken                                   | | -------------------------- | -------------------------------------------- | | Bali (Interpreter)         | 268.5ms (best case) - 275.5ms (worst case)   | | Bali (JIT)                 | 162.4ms (best case) - 169.2ms (worst case)   |</p> <p>Here, the JIT is 1.65x faster than the interpreter!</p>"},{"location":"#contact-me","title":"Contact Me","text":"<p>You can join the Ferus Discord Server to discuss Bali and other components of the Ferus web engine.</p>"},{"location":"#specification-compliance","title":"Specification Compliance","text":"<p>As of 9th of November, 2024, Bali can successfully run 1% of the entire Test262 suite* (I believe that our test runner is currently under-estimating). There's a lot of work to be done here, so don't shy away from sending in PRs. ;)</p>"},{"location":"#running-code-with-bali","title":"Running code with Bali","text":"<p>You can compile Balde, the Bali debugger by running:</p> <pre><code>$ nimble build balde\n</code></pre> <p>You can run it with no arguments and it'll start up in a REPL.  It is primarily used for debugging the engine as of right now, but it runs code fine too.</p>"},{"location":"#integrating-bali-into-your-applications","title":"Integrating Bali into your applications","text":"<p>Bali requires the C++ backend to be used as it depends on simdutf and LibICU!</p> <p>You need to provide Bali with three dependencies: simdutf, icu (version 76) and gmp. Most of these can be installed via your system's package manager.</p> <p>Firstly, add Bali to your project's dependencies.</p> <pre><code>$ nimble add gh:ferus-web/bali\n</code></pre> <p>Here is a basic example of the API:</p> <pre><code>import pkg/bali/grammar/prelude\nimport pkg/bali/runtime/prelude\n\nconst JS_SRC = \"\"\"\nconsole.log(\"Hello world!\")\nconsole.log(13 + 37)\n\nvar myUrl = new URL(\"https://github.com/ferus-web/bali\")\nconsole.warn(myUrl.origin)\n\nvar commitsToBali = 171\nwhile (commitsToBali &lt; 2000) {\n    commitsToBali++\n    console.log(commitsToBali)\n}\n\nfor (var x = 0; x &lt; 32; x++) { console.log(\"Hello, number\", x) }\n\ntry\n{\n    throw \"woe be upon ye\";\n} catch (error_thingy)\n{\n    console.log(error_thingy)\n}\n\nconst encoded = btoa(\"Hello base64\")\n\nlet lemonade = fetchLemonade(4)\nconsole.log(lemonade)\n\"\"\"\n\nlet \n  parser = newParser(JS_SRC) # Feed your JavaScript code to Bali's JavaScript parser\n  ast = parser.parse() # Parse an AST out of the tokens\n  runtime = newRuntime(\"myfile.js\", ast) # Instantiate the JavaScript runtime.\n\n# define a native function which is exposed to the JavaScript code\nruntime.defineFn(\n    \"fetchLemonade\",\n    proc =\n      let num = runtime.ToNumber(&amp;runtime.argument(1))\n\n      if num == 0 or num &gt; 1:\n        ret str(\"You have \" &amp; $num &amp; \" lemonades!\")\n      else:\n        ret str(\"You have a lemonade!\")\n)\n\n# Emit Mirage bytecode and pass over control to the Mirage VM.\n# NOTE: This is a blocking function and will block this thread until execution is completed (or an error is encountered and the\n# interpreter is halted)\nruntime.run()\n</code></pre>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li>[X] Getting a grammar to AST parser</li> <li>[X] Getting the MIR emitter working</li> <li>[X] Get arithmetic operations working</li> <li>[X] Console API</li> <li>[X] While loops</li> <li>[X] Nested object field access</li> <li>[X] <code>typeof</code></li> <li>[X] Arrays</li> <li>[X] REPL</li> <li>[X] String prototype</li> <li>[X] Date prototype</li> <li>[X] Ternary operations</li> <li>[X] Functions as values</li> <li>[X] For-loops</li> <li>[X] Try-catch clauses</li> <li>[X] Compound assignments</li> <li>[X] x86-64 JIT compiler (2 tiers)</li> <li>[ ] Modules</li> <li>[ ] Async</li> </ul>"},{"location":"CODE_STYLE/","title":"The Bali Code Style","text":"<p>This document aims to be a vast corpus of rules that a contributor must follow. These range from recommendations to enforcements. They also range from simply code aesthetics to real semantic changes.</p> <p>Some code in Bali is currently a violation of the rules here. Feel free to send pull requests to fix them.</p>"},{"location":"CODE_STYLE/#general-rules","title":"General Rules","text":"<p>Each commit made to Bali is passed through Nimalyzer, a static analyzer for Nim. Make sure that none of your code messes with it and/or makes its job harder.</p>"},{"location":"CODE_STYLE/#minimize-the-usage-of-templates-to-places-where-it-makes-sense","title":"Minimize the usage of templates to places where it makes sense.","text":"<p>Don't abuse templates. They dilute the codebase with unfollowable stack traces and can also worsen compilation times. \\ Whenever you're about to use a template, think to yourself: \"Would this be better off as a function?\"</p> <p>Here's the cases where it'd absolutely be better off as a function: - It isn't capturing anything that would otherwise trigger Nim's memory safety guardrails if the function were to be inlined. - Turning it into a function would make things more verbose than they need to be, hindering code readability. (A good example of this is the <code>error</code> template in the parser.)</p> <p>Try to avoid templates in the core runtime (the Mirage-Pulsar interpreter), as it makes auditing the code much harder.</p>"},{"location":"CODE_STYLE/#mark-all-unreachable-cases-as-such","title":"Mark all unreachable cases as such.","text":"<p>The <code>unreachable</code> template, defined at <code>bali/internal/sugar</code>, should be used to mark code branches that are assumed to be unreachable as such, if the compiler cannot prove that they truly are unreachable. It can also be used as a temporary safe-crash mechanism for features that have not been fully implemented, but it is preferrable to throw a proper error in such cases.</p>"},{"location":"CODE_STYLE/#defects-vs-exceptions","title":"Defects vs Exceptions","text":"<p>In Nim, defects are unrecoverable errors whilst exceptions are recoverable errors. Treat them as such.</p> <pre><code>type\n  CriticalCodegenBug* = object of ValueError ## We should be able to recover from this, hence the exception...\n  OutOfBoundsTokenRead* = object of Defect   ## Something's went terribly wrong, so it's best we just let the program be killed at this point\n</code></pre>"},{"location":"CODE_STYLE/#use-result-sparingly","title":"Use <code>result</code> sparingly.","text":"<p>The use of the <code>result</code> value makes code ambiguous. Much like the Status IM guide on writing clean Nim, the Bali Code Style recommends you to keep usage of <code>result</code> to a bare minimum. \\ Only use <code>result</code> when you want to set the return value and perform an action afterwards.</p>"},{"location":"CODE_STYLE/#try-to-specify-the-lengths-of-allocations-when-possible","title":"Try to specify the lengths of allocations when possible.","text":"<p>If calculating the length of an allocated buffer like a sequence or string is possible without much hotchpotch and mental gymnastics, do it. \\ Remember, <code>mmap(2)</code> does not take a single CPU cycle.</p> <p>A good example of this would be the following code example:</p> <pre><code>proc convertUint8SeqToUint16*(data: seq[uint8]): seq[uint16] =\n  var converted = newSeq[uint8](data.len) # Preallocate the entire size that we need.\n\n  # Good approach\n  for i, byt in data:\n    converted[i] = uint16(byt)\n\n  # Bad approach\n  for byt in data:\n    converted &amp;= uint16(byt) # Every time we need extra memory to store the new uint16s, we're allocating more memory.\n\n  move(converted)\n</code></pre>"},{"location":"CODE_STYLE/#use-move-semantic-markers-when-needed","title":"Use move semantic markers when needed.","text":"<p>Self-explanatory. This adds an extra layer of clarity to the code, even if not necessary.</p> <pre><code>proc somethingSomething: string =\n  var x = \"hello world\"\n  x &amp;= \"blehhh\"\n\n  result = ensureMove(x) # We're indicating that we no longer need x. Any accesses to x beyond this point will generate a compile-time error.\n  echo x   # Compile-time error!\n</code></pre>"},{"location":"CODE_STYLE/#rules-for-the-grammar-module-tokenizer-parser","title":"Rules for the grammar module (Tokenizer / Parser)","text":""},{"location":"CODE_STYLE/#do-not-interact-with-the-javascript-heap","title":"Do not interact with the JavaScript heap.","text":"<p>Do NOT, under any circumstances, call any of Bali's JavaScript heap management functions (or functions that indirectly call them) in the grammar module!</p> <p>The following functions are guaranteed to allocate on the JavaScript heap: - <code>str()</code> - <code>integer()</code> - <code>floating()</code> - <code>sequence()</code> - <code>undefined()</code> - <code>obj()</code> - <code>bigint()</code> - <code>ident()</code></p> <p>The following functions are their stack-affine, safe-to-use counterparts: - <code>stackStr()</code> - <code>stackInteger()</code> - <code>stackFloating()</code> - <code>stackSequence()</code> - <code>stackUndefined()</code> - <code>stackIdent()</code></p> <p><code>BigInt</code> and <code>Object</code> are not covered, as they are designed to always be allocated on the heap. Use other ways to represent them in the AST.</p> <p>Bali is designed in a way that each component can be used individually, so that, say, a JavaScript LSP written in Nim utilizing Bali's parser needn't initialize the JavaScript heap and the unnecessary overhead, complexity, undeterministicness and safety problems that come along with it.</p>"},{"location":"HEAP/","title":"Bali's Heap","text":"<p>When you create a <code>Runtime</code> object using the <code>newRuntime()</code> function, a <code>HeapManager</code> is initialized by Bali, and that manager context is set as the default heap manager for the thread the program is currently executing on.</p> <p>It uses a bump allocator for the first 8 megabytes of allocations on 64-bit platforms and on 32-bit platforms, it uses it for the first 2 megabytes of allocations. This means that a lot of programs never end up touching the garbage collector, and as a result, become much faster (and make way fewer syscalls!)</p>"},{"location":"HEAP/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Allocating Memory</li> <li>Behind the Scenes</li> </ul>"},{"location":"HEAP/#allocating-memory","title":"Allocating Memory","text":"<p>If you wish to allocate memory with Bali, you need to have a handle to a valid <code>HeapManager</code> instance. If you have a <code>Runtime</code> object with you, you can simply use the <code>heapManager</code> field.</p> <pre><code>import pkg/bali/runtime/vm/heap/manager\n\nlet v = runtime.heapManager.allocate(\"hello world!\".len.uint())\n</code></pre>"},{"location":"HEAP/#behind-the-scenes","title":"Behind the Scenes","text":"<p>When you call <code>allocate()</code>, the following logic is triggered:</p> <ol> <li>Firstly, the <code>HeapManager</code> checks if there is enough memory in the bump allocator or not.</li> <li>If there is, then allocate memory using that.</li> <li>Otherwise, ask the GC to allocate the memory.</li> </ol>"},{"location":"MANUAL/","title":"Bali Manual","text":"<p>Author: Trayambak Rai (xtrayambak at disroot dot org)</p> <p>Version Series Targetted: 0.8.0</p> <p>This manual is largely inspired by Monoucha's manual.</p> <p>WARNING: Bali is only tested with the default memory management strategy (ORC). It uses ORC extensively and as such, it will probably not compile with other strategies.</p> <p>WARNING: If you embed Bali in your program, you must compile it with the C++ backend as Bali relies on some C++ libraries.</p> <p>This manual is largely under construction. Report problems if you can.</p>"},{"location":"MANUAL/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction<ul> <li>Terms to learn<ul> <li>Atom</li> </ul> </li> <li>Drooling Baby's First Scripts</li> <li>Baby's First Scripts</li> <li>The holy grail of Bali, the Runtime structure</li> </ul> </li> <li>Creating new types<ul> <li>Wrapping Primitives</li> <li>Wrapping our Type</li> <li>Modifying our Type's Prototype</li> </ul> </li> <li>Supported ECMAScript APIs<ul> <li>The Math type</li> <li>The JSON type </li> <li>The URL type</li> <li>The BigInt type</li> <li>The String type</li> <li>The Date type</li> <li>The Number type </li> <li>The Set type</li> </ul> </li> <li>Using Balde<ul> <li>Running scripts</li> <li>Flags</li> <li>Using the REPL</li> <li>Experiments</li> </ul> </li> <li>Controlling Codegen<ul> <li>Prelude</li> <li>Loop Elision</li> <li>Loop Allocation Elision</li> <li>Return-value register scrubber</li> <li>Disabling optimizations</li> </ul> </li> <li>Using the Native Interface<ul> <li>A small example</li> <li>Allocating memory</li> </ul> </li> <li>Migration Notices<ul> <li>0.7.x -&gt; 0.8.0</li> </ul> </li> </ul>"},{"location":"MANUAL/#introduction","title":"Introduction","text":"<p>Bali is a JavaScript engine written from scratch in Nim for the Ferus web engine. It is designed to be convenient to interface with whilst being fast and compliant. It provides you high-level abstractions as far as humanly possible.</p> <p>Currently, it has a fairly-fast bytecode VM as well as a baseline JIT compiler for x86-64 SysV systems.</p> <p>Bali is evolving very quickly, and as such, the API is subject to breaking. Such changes will be generally marked by a bump in the minor version.</p>"},{"location":"MANUAL/#terms-to-learn","title":"Terms to learn","text":"<p>Although not evident at first, learning these terms will make things much easier for you.</p>"},{"location":"MANUAL/#atom","title":"Atom","text":"<p>An atom is a variant type discriminated by its <code>kind</code> field that can be: - An integer (signed) - An integer (unsigned) - A float (64-bit) - A string - A sequence (of more atoms, but you can mark it as homogenous to restrict it to one type) - An object (basically, an overglorified hashmap) There's also an identifier type, but that's only internally used by Mirage.</p> <p>A <code>JSValue</code> is a pointer to an atom, and it is generally what is used instead of a <code>MAtom</code>, to facilitate easier value manipulation.</p>"},{"location":"MANUAL/#drooling-babys-first-scripts","title":"Drooling Baby's First Scripts","text":"<p>We'll now learn how to use Bali's <code>easy</code> module, which as the name suggests, gives you the simplest-possible way to execute JavaScript in Nim. It is incredibly dumbed down, and you're recommended to not use it for serious projects where more control over the entire execution flow is required.</p> <p>All you need to is import a single component: <code>bali/easy</code></p> <pre><code>import pkg/bali/easy\n\nproc main() =\n  var runtime = createRuntimeForSource(\n    \"\"\"\nconsole.log(\"Goo goo ga ga\")\nconsole.log(\"It doesn't get simpler than this.\")\n  \"\"\"\n  )\n\n  runtime.run()\n\nwhen isMainModule:\n  main()\n</code></pre> <p>It's mostly meant to be used as a gentle introduction to using Bali.</p>"},{"location":"MANUAL/#babys-first-scripts","title":"Baby's First Scripts","text":"<p>Now, we'll learn how to write a Nim program that can load and evaluate JavaScript. You'll need to import two of Bali's components: - The <code>grammar</code> module, which as the name suggests, is responsible for lexing and parsing the JavaScript source code into an abstract syntax tree - The <code>runtime</code> module, which takes in the AST and converts it into bytecode that targets the Mirage/Pulsar interpreter.</p> <p>However, all of the complexities are neatly abstracted away, so you needn't worry about all of that. The API is deceptively simple. Here's the minimal example.</p> <pre><code>import pkg/bali/grammar/prelude\nimport pkg/bali/runtime/prelude\n\n# Create a parser.\nlet parser = newParser(\"\"\"\nconsole.log(\"Hello from JavaScript!\")\n\"\"\")\n\n# Parse the source code into an AST.\nlet ast = parser.parse()\n\n# Instantiate the runtime, which generates the bytecode and runs it.\n# You can optionally pass on a filename, it only exists to keep the\n# bytecode caching mechanism work.\nlet runtime = newRuntime(\"nameofyourfile.js\", ast)\n\n# Begin execution. This halts your code until execution is completed.\nruntime.run()\n</code></pre> <p>Let's breakdown what each line does: - We're creating a parser with <code>newParser()</code> and feeding it our source code. - We're parsing the source code into an abstract syntax tree. - We're feeding the AST to the runtime. - We're running the generated bytecode.</p> <p>That's it! You just executed JavaScript with Bali! Yay.</p>"},{"location":"MANUAL/#the-holy-grail-of-bali-the-runtime-structure","title":"The holy grail of Bali, the Runtime structure","text":"<p>The <code>Runtime</code> type is what you initialize when you wish to execute JavaScript. It acts as a catalyst where various different Bali subsystems intersect and work together. It helps you do the following things:</p> <ul> <li>Expose your custom types written in Nim to JavaScript</li> <li>Expose your Nim-native functions to JavaScript (for instance, you can create a <code>perlinNoise()</code> function and implement it in Nim so that it's fast!)</li> <li>Set properties on types</li> <li>Call JavaScript functions and get their return values in Nim and much, much more.</li> </ul> <p>Basically, if you wish to do anything with Bali apart from just using it as a script executor, chances are that you'll need to interact with the <code>Runtime</code> structure, obtained via <code>newRuntime()</code> or the <code>createRuntimeForFile()</code> / <code>createRuntimeForSource()</code> functions.</p>"},{"location":"MANUAL/#creating-new-types","title":"Creating new types","text":"<p>Now, let us learn how to create new types. Bali can automatically \"wrap\" a Nim object into its representative atom. Bali can do this for primitives like integers, floats, strings and sequences of said primitives as well.</p>"},{"location":"MANUAL/#wrapping-primitives","title":"Wrapping Primitives","text":"<p>Let us try wrapping some primitives into atoms before wrapping a Nim object.</p> <pre><code>import std/options\nimport pkg/bali/runtime/prelude\n\nlet name = \"John Doe\"\nlet age = 24'u\nlet likes = @[\"Skating\", \"Tennis\", \"Programming\"]\n\nlet aName = runtime.wrap(name)\nlet aAge = runtime.wrap(age)\nlet aLikes = runtime.wrap(likes)\n\nassert aName.kind == String\nassert aAge.kind == Integer\nassert aLikes.kind == Sequence\n\nassert aName.isSome and aName.getStr().get() == name\nassert aAge.isSome and aAge.getInt().get() == age\n</code></pre> <p>NOTE: When you call <code>wrap()</code>, Bali allocates the object's on the heap, which is normally controlled by the Boehm GC! Do not free the pointer unless you're 100% sure it's no longer needed. Due to how Bali is designed, deallocating a <code>JSValue</code> can cause a ripple effect where other parts of the code holding onto the pointer won't notice it, and will subsequently perform a user-after-free! Henceforth, leave deallocations to the GC, because it's smarter than you. Here, we just turned Nim types into atoms, which can be of any type, only dictated by their <code>kind</code> field. We can also turn the first two atoms back into their original representation. Unfortunately, it isn't as simple for the sequence, which can be dynamically typed with heterogenous types at this point. The <code>getXXX</code> functions return <code>Option[requested type]</code> as they need to safely provide a way to tell if an atom can be of the requested primitive type. </p>"},{"location":"MANUAL/#hold-up-this-isnt-how-javascript-engines-work","title":"Hold up, this isn't how JavaScript engines work!","text":"<p>Yep, they use coercion. You could implement coercion like this using the exception system, but Bali already handles some of the coercion functions that ECMAScript expects. They'll be covered later.</p>"},{"location":"MANUAL/#wrapping-our-type","title":"Wrapping our Type","text":"<p>Assuming you already have the runtime set up via <code>newRuntime()</code>, you can define types before <code>run()</code> is called.</p> <pre><code>type Person* = object\n  name*: string\n  age*: uint\n  likes*: seq[string]\n\nruntime.registerType(prototype = Person, name = \"Person\")\nruntime.setProperty(Person, \"name\", str(runtime, \"John Doe\"))\nruntime.setProperty(Person, \"age\", integer(runtime, 24'u))\nruntime.setProperty(Person, \"likes\", sequence(runtime, @[\n  str(runtime, \"Skating\"),\n  str(runtime, \"Tennis\"),\n  str(runtime, \"Programming\")\n]))\n</code></pre> <p>Here, we're exposing our <code>Person</code> type to the JavaScript environment by specifying what fields it has, and also setting those fields. Now, you can easily just run this in your JS code:</p> <pre><code>console.log(Person.name) // Log: John Doe\nconsole.log(Person.age) // Log: 24\nconsole.log(Person.likes) // Log: [Skating, Tennis, Programming]\n</code></pre> <p>You might notice that when we create JavaScript values, we need to pass our <code>Runtime</code> instance to the functions. This is because the function will then use our runtime's isolated heap context to allocate memory for the object. Earlier versions of Bali utilized a global, shared, thread-local heap context. As one might expect, this caused all sorts of issues, ranging from thread-offloading being impossible, to test-code drivers being very wonky.</p>"},{"location":"MANUAL/#modifying-our-prototype","title":"Modifying our Prototype","text":"<p>Now, what if you wanted to add a function that can be called by every instance of your type? In order to do that, you need to modify its prototype. Assume that we want multiple instances of the previously defined <code>Person</code> class to be possible. We need to define a constructor for it.</p> <pre><code>runtime.defineConstructor(\n    \"Person\",\n    proc =\n      let\n        name = runtime.ToString(&amp;runtime.argument(1), required = true, message = \"Expected `name` argument at pos 1, got {nargs}\")\n        age = runtime.ToNumber(&amp;runtime.argument(2), required = true, message = \"Expected `age` argument at pos 2, got {nargs}\")\n\n      let person = Person(name: name, age: age.uint)\n\n      ret person\n)\n</code></pre> <p>Now, we can call <code>new Person(\"John Doe\", 24)</code> in JavaScript land and get an instance of the <code>Person</code> class! Let us assume you want a <code>greet</code> function for all <code>Person</code>(s) that returns \" greets you back.\". We can implement it like this. <pre><code>runtime.definePrototypeFn(\n    Person,\n    \"greet\",\n    proc(value: JSValue) =\n      let \n        name = runtime.ToString(value[\"name\"])\n        age = runtime.ToNumber(value[\"age\"])\n\n      echo name &amp; \" greets you back.\"\n)\n</code></pre> <p>Let us break that down, shall we?</p> <ul> <li><code>definePrototypeFn</code>, as the name suggests, sets up a function for a type's prototype. This prototype is copied to all of the instances of that type, and all of the child classes that derive from this one, and so on and so forth.</li> <li>You might be wondering what <code>value</code> here is. It's actually the <code>Person</code> type we called <code>ret</code> on to pass it over to JS-land. It's now in the form of an atom, and unfortunately there's no way to easily turn it back into its original representation, atleast right now.</li> </ul> <p>Now, the following code should work fine:</p> <pre><code>let john = new Person(\"John Doe\", 23)\nlet jane = new Person(\"Jane Doe\", 28)\n\njohn.greet()\njane.greet()\n</code></pre>"},{"location":"MANUAL/#supported-ecmascript-apis","title":"Supported ECMAScript APIs","text":"<p>Bali supports the following ECMAScript APIs.</p>"},{"location":"MANUAL/#the-math-type","title":"The Math Type","text":"<p>The <code>Math</code> type contains the following methods.</p>"},{"location":"MANUAL/#mathrandom","title":"<code>Math.random</code>","text":"<p>This function uses the global RNG instance created via librng to generate a float between 0 and 1. WARNING: Do NOT tuse this function in places like cryptography! All of the PRNG algorithms used are highly predictable!</p>"},{"location":"MANUAL/#using-another-rng-algorithm","title":"Using another RNG algorithm","text":"<p>You can pass the following values as arguments for <code>--define:BaliRNGAlgorithm</code>:</p> <ul> <li><code>xoroshiro128</code>: Xoroshiro128</li> <li><code>xoroshiro128pp</code>: Xoroshiro128++</li> <li><code>xoroshiro128ss</code>: Xoroshiro128**</li> <li><code>mersenne_twister</code>: Mersenne Twister</li> <li><code>marsaglia</code>: Marsaglia 69069</li> <li><code>pcg</code>: PCG</li> <li><code>lehmer</code>: Lehmer64</li> <li><code>splitmix</code>: Splitmix64</li> </ul> <p>All of them vary in terms of quality, footprint and speed. Bali defaults to <code>xoroshiro128</code> as it provides a nice balance between all of those.</p>"},{"location":"MANUAL/#the-rest-of-the-functions","title":"The rest of the functions","text":"<p>All of the functions apart from <code>Math.hypot</code> have been implemented.</p>"},{"location":"MANUAL/#the-json-type","title":"The JSON type","text":"<p>The <code>JSON</code> type has been implemented using the jsony parser. It contains a routine to turn Nim's <code>JsonNode</code> structs into <code>JSValue</code>(s) on the fly. It is not very spec-compliant yet, and just exists for my convenience.</p>"},{"location":"MANUAL/#supported-routines","title":"Supported Routines","text":"<ul> <li><code>JSON.parse()</code></li> <li><code>JSON.stringify()</code></li> </ul>"},{"location":"MANUAL/#the-url-type","title":"The URL type","text":"<p>The <code>URL</code> type is not part of the JavaScript spec, but we implement it anyways. It uses Ferus' sanchar parser under the hood.</p>"},{"location":"MANUAL/#supported-routines_1","title":"Supported Routines","text":"<ul> <li><code>new URL()</code> constructor</li> <li><code>URL.parse()</code></li> </ul>"},{"location":"MANUAL/#the-bigint-type","title":"The BigInt type","text":"<p>The <code>BigInt</code> type has been implemented, but the vast majority of its routines have not. It uses the GNU MP BigNum library under the hood.</p>"},{"location":"MANUAL/#supported-routines_2","title":"Supported Routines","text":"<ul> <li><code>new BigInt()</code> constructor</li> <li><code>BigInt.prototype.toString()</code></li> </ul>"},{"location":"MANUAL/#the-string-type","title":"The String type","text":"<p>This is perhaps the most complete implemented-by-Bali ECMAScript type here. It uses Kaleidoscope and simdutf under the hood.</p>"},{"location":"MANUAL/#supported-routines_3","title":"Supported Routines","text":"<ul> <li><code>new String()</code> constructor</li> <li><code>String.prototype.indexOf()</code></li> <li><code>String.prototype.concat()</code></li> <li><code>String.prototype.trimStart()</code> / <code>String.prototype.trimLeft()</code></li> <li><code>String.prototype.trimEnd()</code> / <code>String.prototype.trimRight()</code></li> <li><code>String.prototype.toLowerCase()</code></li> <li><code>String.prototype.toUpperCase()</code></li> <li><code>String.prototype.repeat()</code></li> <li><code>String.fromCharCode()</code></li> <li><code>String.prototype.codePointAt()</code></li> <li><code>String.prototype.substring()</code></li> <li><code>String.prototype.charAt()</code></li> <li><code>String.prototype.at()</code></li> </ul>"},{"location":"MANUAL/#the-date-type","title":"The Date type","text":"<p>This is yet another well-implemented-by-Bali ECMAScript type. It uses a mixture of LibICU and internal math-based logic, mostly translated from Ladybird's LibJS.</p>"},{"location":"MANUAL/#supported-routines_4","title":"Supported Routines","text":"<ul> <li><code>new Date()</code> constructor</li> <li><code>Date.now()</code></li> <li><code>Date.parse()</code></li> <li><code>Date.prototype.getYear()</code></li> <li><code>Date.prototype.getFullYear()</code></li> <li><code>Date.prototype.toString()</code></li> <li><code>Date.prototype.getDay()</code></li> <li><code>Date.prototype.getDate()</code></li> </ul>"},{"location":"MANUAL/#the-number-type","title":"The Number type","text":"<p>This is just a boxed representation of a number.</p>"},{"location":"MANUAL/#supported-routines_5","title":"Supported Routines","text":"<ul> <li><code>Number.isFinite()</code></li> <li><code>Number.isNaN()</code></li> <li><code>Number.parseInt()</code></li> <li><code>Number.NaN</code></li> <li><code>Number.EPSILON</code></li> <li><code>Number.prototype.toString()</code></li> <li><code>Number.prototype.valueOf()</code></li> </ul>"},{"location":"MANUAL/#the-set-type","title":"The Set type","text":"<p>The Set type uses a Sequence atom under the hood, with guards to ensure that no duplicated values can get lodged in on accident.</p>"},{"location":"MANUAL/#supported-routines_6","title":"Supported Routines","text":"<ul> <li><code>new Set()</code></li> <li><code>Set.prototype.toString()</code></li> <li><code>Set.prototype.add()</code></li> <li><code>Set.prototype.size()</code></li> <li><code>Set.prototype.delete()</code></li> <li><code>Set.prototype.has()</code></li> <li><code>Set.prototype.clear()</code></li> </ul>"},{"location":"MANUAL/#using-balde","title":"Using Balde","text":"<p>Balde, short for \"Bali debugger\" is a CLI tool that acts both as a script runner and a REPL.</p>"},{"location":"MANUAL/#running-scripts","title":"Running Scripts","text":"<p>Running a JavaScript source file is as simple as:</p> <pre><code>$ balde path/to/your/file.js\n</code></pre>"},{"location":"MANUAL/#flags","title":"Flags","text":"<p>Balde supports a few flags for easier debugging.</p>"},{"location":"MANUAL/#-dump-ast","title":"<code>--dump-ast</code>","text":"<p>This flag lets the runtime evaluate the AST for any errors, but does not allow for its execution. Instead, it prints out the AST instead. This allows for semantic errors to be thrown out. If you want an immediate AST dump, use <code>--dump-no-eval</code>.</p> <pre><code>$ balde path/to/your/file.js --dump-ast\n&lt;AST representation&gt;\n</code></pre>"},{"location":"MANUAL/#-dump-no-eval","title":"<code>--dump-no-eval</code>","text":"<p>This flag dumps the parsed representation (or AST) of the provided JavaScript source without any further evaluation. It also includes the parsing errors.</p> <pre><code>$ balde path/to/your/file.js --dump-no-eval\n&lt;AST representation&gt;\n</code></pre>"},{"location":"MANUAL/#-verbose","title":"<code>--verbose</code>","text":"<p>This flag allows all debug logs to be shown, which can be used to diagnose bugs in the engine's multiple phases (tokenization, parsing, bytecode generation and runtime). Beware that this gets very spammy.</p> <pre><code>$ balde path/to/your/file.js --verbose\n&lt;A boat load of logs&gt;\n</code></pre>"},{"location":"MANUAL/#-dump-tokens","title":"<code>--dump-tokens</code>","text":"<p>This flag dumps all of the tokens of a JavaScript source file.</p> <pre><code>$ balde path/to/your/file.js --dump-tokens\n</code></pre>"},{"location":"MANUAL/#using-the-repl","title":"Using the REPL","text":"<p>WARNING: The REPL is still a very unstable feature. It is known to have several bugs. To run the REPL, simply run Balde with no arguments.</p>"},{"location":"MANUAL/#experiments","title":"Experiments","text":"<p>Experiments are unstable Bali features that are locked behind an interpreter flag. In order to use them, you need to use the <code>--enable-experiments</code> flag. <code>--enable-experiments</code> expects a syntax like this:</p> <pre><code>--enable-experiments:&lt;experiment1&gt;;&lt;experiment2&gt;\n</code></pre>"},{"location":"MANUAL/#current-experiments","title":"Current Experiments","text":"<p>There are currently no active experimental features.</p>"},{"location":"MANUAL/#controlling-codegen","title":"Controlling Codegen","text":"<p>Bali exposes some levers to turn on/off some code generation features. This features help Bali emit faster bytecode by skipping certain expensive portions of the provided JS source into code that does roughly the same thing.</p> <p>If the optimized code does not perform the same behaviour as the unoptimized code, that is a bug. You should probably report it to me after you're 100% sure that it isn't a problem on your part.</p>"},{"location":"MANUAL/#prelude","title":"Prelude","text":"<p>Bali exposes three code generation optimizations as of right now: - Loop Elider - Loop Allocation Eliminator - Return-value register scrubbing</p>"},{"location":"MANUAL/#loop-elision","title":"Loop Elision","text":"<p>Say, we have some code like this (this is very stupid, most people don't write code like this):</p> <pre><code>var i = 0\nwhile (i &lt; 999999)\n{\n    i++\n}\n</code></pre> <p>Bali can successfully prove that the while-loop only exists to modify the loop's state controller (<code>i</code>) in a particular way (increment it in this case) Bali now knows that there is not a need to: * Waste storage space by generating code for a loop * Waste CPU cycles by iterating 999999 times As such, it can compute the result that will be stored at the end in the <code>i</code> variable and turns the code into the rough equivalent of this:</p> <pre><code>var i = 999999\n</code></pre> <p>This also works for decrements, as intended.</p> <p>There are a few cases where the loop elision will correctly fallback and actually generate the loop's code if it detects that a loop does more than mutate its own state.</p> <pre><code>var i = 0\nwhile (i &lt; 999999)\n{\n    i++ // This is fine.\n    console.log(i) // Woops: we can't elide that loop now!\n}\n</code></pre> <p>Now, it realizes that it has to actually generate the loop. Loop elision makes Bali really fast against other JavaScript engines for very specifically cherry picked benchmarks, but serves next to no real-world usage. Yet.</p>"},{"location":"MANUAL/#loop-allocation-elision","title":"Loop Allocation Elision","text":"<p>Say, we have some code like this (this actually happens in a lot of places):</p> <pre><code>while (true)\n{\n  let x = \"Programming se me utsahit hota hun. Me vyavsaik programmer hun, aur tum ise idhar dekh sakte ho. Ye mera kaushal he.\"\n  console.log(x)\n}\n</code></pre> <p>AFAIK, other JavaScript engines like V8 and SpiderMonkey have an internal string interning \"cache\" to prevent allocating the same string again and again. Bali takes a different approach, because why not?</p> <p>Before a loop is about to be generated, Bali runs an optimization pass over the body to check if any allocations can be moved outside the loop's body. The aforementioned code sample, hence, would be converted into this:</p> <pre><code>let x = \"Programming se me utsahit hota hun. Me vyavsaik programmer hun, aur tum ise idhar dekh sakte ho. Ye mera kaushal he.\"\n\nwhile (true)\n{\n  console.log(x)\n}\n</code></pre> <p>This prevents unnecessary allocations. Yay.</p>"},{"location":"MANUAL/#return-value-register-scrubber","title":"Return-Value Register Scrubber","text":"<p>This optimization essentially allows the engine to emit the <code>ZRETV</code> instruction. This instruction clears the return-value register, which allows the garbage collector to quickly clear up the memory it might occupy. This makes some badly written code no longer result in an OOM. It, however, like most of Bali, is not battle tested and as such, might result in undefined behaviour. It is disabled by default.</p>"},{"location":"MANUAL/#disabling-optimizations","title":"Disabling Optimizations","text":"<p>If you don't want the bytecode generator to spend time optimizing code (you're 100% sure you've written very neat code that will always make your CPU happy or something) or the bytecode generator ends up performing optimization incorrectly (rare, but if it occurs, please file a bug report), then you can disable codegen optimizations.</p>"},{"location":"MANUAL/#disabling-optimizations-in-balde","title":"Disabling Optimizations in Balde","text":"<p>Balde exposes the following three flags to control optimizations: * --disable-loop-elision * --disable-loop-allocation-elim * --aggressively-free-retvals * --disable-jit</p>"},{"location":"MANUAL/#disabling-optimizations-in-nim-code","title":"Disabling Optimizations in Nim code","text":"<p>When instantiating the <code>Runtime</code>, you can pass an <code>InterpreterOpts</code> struct containing a <code>CodegenOpts</code> struct.</p> <pre><code>var runtime = newRuntime(\n  fileName, ast, \n  InterpreterOpts(\n    codegen: CodegenOpts(\n      elideLoops: false,\n      loopAllocationEliminator: false,\n      aggressivelyFreeRetvals: false,\n      jitCompiler: false\n    )\n  )\n)\n</code></pre>"},{"location":"MANUAL/#using-the-native-interface","title":"Using the Native Interface","text":""},{"location":"MANUAL/#a-small-example","title":"A small example","text":"<p>Bali exposes a pretty neat two-way interface for native code written in Nim to interact with JavaScript, and vice versa. Here's a short example. Here's a brief summary of what it does: - The JavaScript code has a function called \"shoutify\" which takes in an argument and returns an all-upper-case version of it. - The Nim code has a function called \"greet\" which takes in an argument and prints \"Hi there, \" to stdout. - The JS code firstly calls the native greet function, passing \"tray\" as an argument. As expected, \"Hi there, tray\" gets printed to stdout. - After the execution is done, the Nim code tries finding a reference to the \"shoutify\" function in the global scope. - Then, it calls this function from Nim-land with the argument \"tray\". - The JS function turns this argument all into uppercase (\"TRAY\") and returns it. - Then, the Nim-land code gets it back and prints it out. <pre><code>import pkg/bali/grammar/prelude\nimport pkg/bali/runtime/prelude\n\nproc main =\n  let parser = newParser(\n    \"\"\"\nlet greeting = greet(\"tray\") // Here, we're calling a native function written in Nim\nconsole.log(greeting)\n\nfunction shoutify(name)\n{\n  // Make a name seem like it's been SHOUTED OUT.\n  // This is called by native code.\n  var x = new String(name);\n  var y = x.toUpperCase() // Fun fact: `toUpperCase()` is native code. So here, we have native code calling interpreted code, which in turn calls more native code. :^)\n\n  return y\n}\n\"\"\"\n  )\n  let ast = parser.parse()\n  var runtime = newRuntime(\"interop.js\", ast)\n\n  runtime.defineFn(\n    \"greet\",\n    proc() =\n      let arg = runtime.ToString(&amp;runtime.argument(1))\n      ret str(runtime, \"Hi there, \" &amp; arg)\n    ,\n  )\n\n  runtime.run() # Execute what we have so far.\n\n  let fn = runtime.get(\"shoutify\") # Get the `shoutify` value reference in the global scope\n  if !fn:\n    return\n\n  let retval = runtime.call(&amp;fn, str(\"tray\")) # Call the `shoutify` function in bytecode. Pass it the arguments it expects.\n  echo \"I AM SHOUTING YOUR NAME AT YOU, \" &amp; runtime.ToString(retval) # Take its return value and print it out.\n</code></pre>"},{"location":"MANUAL/#allocating-memory","title":"Allocating memory","text":"<p>Bali lets the programmer allocate memory in the same way as JavaScript code using the <code>HeapManager</code> API. Each <code>Runtime</code> instance has one attached to it. \\ This essentially lets you tap into Bali's allocation flow. In most cases, however, you do not need to do this. All of the <code>JSValue</code>-returning functions already use your <code>Runtime</code> instance's internal heap context.</p> <pre><code>import pkg/bali/runtime/vm/heap/manager\n\nlet x = runtime.heapManager.allocate(1337) # allocate 1337 bytes\n</code></pre> <p>This essentially performs the following steps: 1. If the bump allocator has enough memory leftover for this allocation, it uses that. 2. Otherwise, it calls into the GC to fetch the pointer of said size.</p> <p>If allocation fails, the <code>AllocationFailed</code> defect is thrown.</p>"},{"location":"MANUAL/#migration-notices","title":"Migration Notices","text":"<p>Bali is constantly evolving in terms of its design, architecture and subsystems. Here's a few notes that can help you migrate from one version to another with the least amount of headaches.</p>"},{"location":"MANUAL/#07x-to-080","title":"0.7.x to 0.8.0","text":"<p>0.7.8 was bumped to 0.8.0 for one major reason: All global states have been fully eliminated.</p> <p>This brings a plethora of benefits with it, which you can probably guess. However, it also breaks most code written for any version prior to 0.8.0! Thankfully, the migration process is fairly straightforward. All functions that perform allocations on the JavaScript heap need to modified.</p> <p>Assuming your initialized <code>Runtime</code> instance is at <code>runtime</code>, the following migrations will suffice in the illustrated examples: * <code>str(\"Hello World!\")</code> -&gt; <code>str(runtime, \"Hello World!\")</code> * <code>obj()</code> -&gt; <code>obj(runtime)</code> * <code>floating(13.37)</code> -&gt; <code>floating(runtime, 13.37)</code> * <code>sequence(@[])</code> -&gt; <code>sequence(runtime, @[])</code> * <code>bigint(\"383248324832843284832483248324\")</code> -&gt; <code>bigint(runtime, \"383248324832843284832483248324\")</code></p> <p>And so on, and so forth.</p> <p>Another change is that the death callback is now a member of the <code>Runtime</code> struct and needs to be set via the <code>deathCallback</code> property, instead of using the previously provided function. The signature for the death callback has also been changed from <code>proc(PulsarInterpreter, int)</code> to <code>proc(PulsarInterpreter)</code>.</p>"},{"location":"PULSAR/","title":"Pulsar","text":"<p>Bali uses an interpreter called Pulsar. It is a fairly fast interpreter that uses an unorthodox mix of a valuespace (called the \"stack\" internally, as in a stack of values) as well as special-purpose registers for various purposes like passing arguments to functions, and taking out the return value from one.</p>"},{"location":"PULSAR/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Design</li> <li>From codegen to execution<ul> <li>Bootstrapping</li> </ul> </li> </ul>"},{"location":"PULSAR/#design","title":"Design","text":"<p>Bali, like most JavaScript engines, starts off by lowering the abstract syntax-tree into a bytecode format it calls MIR.</p> <p>Prior to 0.7.2, Bali would do an incredibly wasteful pass of generating the bytecode structures, emitting it as a string, then parsing that string into the VM's bytecode structures. Since that version, Bali instead converts the bytecode structures directly into the VM's structures, saving a lot of unnecessary memory allocations.</p> <p>The bytecode format originally started off its life as part of the Mirage project. However, ever since the VM was moved into the source tree from Mirage, the two formats have diverged radically and are no longer compatible with one another, despite looking fairly similar. Bali does, though, carry a lot of legacy baggage from this as Mirage was supposed to be as agnostic as possible, while Bali's VM is strictly focused on JavaScript. More on this will be more obvious to you soon.</p> <p>After 0.7.5, Pulsar uses a dispatch table instead of the massive switch case used earlier.</p>"},{"location":"PULSAR/#from-codegen-to-execution","title":"From codegen to execution","text":"<p>Let's take a very simple JavaScript program:</p> <pre><code>console.log(\"Hello, world!\")\n</code></pre> <p>If we use Balde with the <code>--dump-bytecode</code> flag, we can check out what the lowering mechanism generates for this code:</p> <pre><code># Bytecode generated by Bali\n# Bali is a JavaScript engine under the Ferus project.\n# For more information, visit https://github.com/ferus-web/bali\n# Developed by the Ferus Authors for the Ferus Project\n\n# Clause/CodeModule \"String\"\n# Operations: 1\nCLAUSE String\n        1 CALL BALI_STRING\nEND String\n\n# Clause/CodeModule \"atob\"\n# Operations: 1\nCLAUSE atob\n        1 CALL BALI_ATOB\nEND atob\n\n# Clause/CodeModule \"btoa\"\n# Operations: 1\nCLAUSE btoa\n        1 CALL BALI_BTOA\nEND btoa\n\n# Clause/CodeModule \"encodeURI\"\n# Operations: 1\nCLAUSE encodeURI\n        1 CALL BALI_ENCODEURI\nEND encodeURI\n\n# Clause/CodeModule \"BigInt\"\n# Operations: 1\nCLAUSE BigInt\n        1 CALL BALI_BIGINT\nEND BigInt\n\n# Clause/CodeModule \"parseInt\"\n# Operations: 1\nCLAUSE parseInt\n        1 CALL BALI_PARSEINT\nEND parseInt\n\n# Clause/CodeModule \"outer\"\n# Operations: 36\nCLAUSE outer\n        1 LDUD 0\n        2 LDF 1 nan\n        3 LDF 5 inf\n        4 LDB 2 true\n        5 LDB 3 false\n        6 LDN 4\n        7 CFLD 7 0 \"@bali_object_type\"\n        8 CFLD 8 0 \"@bali_object_type\"\n        9 CFLD 9 0 \"@bali_object_type\"\n        10 CFLD 10 0 \"@bali_object_type\"\n        11 CFLD 11 0 \"@bali_object_type\"\n        12 CFLD 12 0 \"@bali_object_type\"\n        13 CFLD 13 0 \"@bali_object_type\"\n        14 CFLD 14 0 \"@bali_object_type\"\n        15 CFLD 15 0 \"@bali_object_type\"\n        16 CFLD 16 0 \"@bali_object_type\"\n        17 LDS 17 \"Hello, world!\"\n        18 PARG 17\n        19 CALL BALI_CONSTRUCTOR_STRING\n        20 RARG\n        21 RREG 17 0\n        22 ZRETV\n        23 RARG\n        24 LDN 18\n        25 LDUI 20 8\n        26 PARG 20\n        27 LDUI 21 18\n        28 PARG 21\n        29 LDS 21 \"log\"\n        30 PARG 21\n        31 CALL BALI_RESOLVEFIELD\n        32 RARG\n        33 PARG 17\n        34 INVK 18\n        35 RARG\n        36 ZRETV\nEND outer\n</code></pre> <p>That's quite a mouthful, isn't it? Let us ignore all clauses apart from <code>outer</code>, for they exist just for some of the runtime's features to function properly. By the way, this is in debug mode, where the emitter generates additional comments. The bytecode that'd be printed would be much more condensed otherwise.</p>"},{"location":"PULSAR/#bootstrapping","title":"Bootstrapping","text":"<p>Instruction 1 loads <code>undefined</code> at position 0. This is where all failed identifier indexing attempts during codegen point to. Instruction 2 loads <code>NaN</code> at position 1, and so on.</p> <p>This is the part of the bytecode we call \"bootstrapping\". It essentially preps up the VM to handle what is to come.</p> <p>It also creates a field called <code>@bali_object_type</code> in a lot of <code>Object</code>(s) created discreetly in the native initialization phase. This is an internal tag used by the engine.</p>"},{"location":"jit/AGNIPATH/","title":"Agnipath","text":"<p>Agnipath (literally means \"path of fire\" in Hindi, I like to think of it as \"hotpath\") is the highest-tier JIT compiler in Bali. It aims to minimize boxing+unboxing and also produce the best quality code possible, no matter how much time it takes.</p> <p>It uses a SSA IR form to make certain optimizations trivial.</p> <p>It currently does not exist, I am planning to work on it soon.</p>"},{"location":"jit/BASELINE/","title":"The Baseline Compiler","text":"<p>Bali's baseline compiler is a fairly naive, simple (~440 LoC) JIT compiler that directly translates the VM's bytecode structures to native x86-64 code.</p> <p>It does not attempt to perform any optimizations, as its goal is to generate machine code with as low of a latency as possible. As such, the code generated by it tends to be of very poor quality.</p>"},{"location":"jit/BASELINE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Function Compilation Eligiblity</li> <li>Optimizations</li> </ul>"},{"location":"jit/BASELINE/#function-compilation-eligibility","title":"Function Compilation Eligibility","text":"<p>A function becomes eligible to be compiled by this tier when it occupies 15% of all the bytecode execution dispatches in the interpreter, after 50,000 total dispatches have been hit. If not, then the function continues to be executed by the interpreter (pulsar).</p>"},{"location":"jit/BASELINE/#optimizations","title":"Optimizations","text":"<p>This tier is a 1:1 bytecode to machine code translator. It does not perform ANY optimizations, because the goal is for it to be as fast as possible.</p>"},{"location":"jit/MADHYASTHAL/","title":"Madhyasthal","text":"<p>Bali has had a baseline JIT compiler since 0.7.0 - known as the baseline compiler. It translates the VM's bytecode structures directly into native x86-64 code. \\ It is very fast, but its code generation quality is very bad. It does not perform any optimizations on the clause given to it.</p> <p>Keeping this in mind, Madhyasthal (literally meaning \"middle place\" in Hindi) was created. As the name might suggest, it aims to be the middle-point between the baseline JIT and any future higher-tier compilers that may be implemented. It generates much better code than the baseline, at the cost of taking slightly longer to generate the code.</p>"},{"location":"jit/MADHYASTHAL/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Function Compilation Eligibity</li> <li>Design</li> <li>Intermediate Representation</li> <li>Lowering</li> <li>Optimizations</li> <li>Code Generation</li> </ul>"},{"location":"jit/MADHYASTHAL/#function-compilation-eligibility","title":"Function Compilation Eligibility","text":"<p>A function becomes eligible to be compiled by this tier when the <code>getCompilationJudgement()</code> returns its judgement as <code>CompilationJudgement.WarmingUp</code>. This occurs when:</p> <ul> <li>50,000 bytecode instruction dispatches have occurred</li> <li>The aforementioned function has been responsible for over 35% of said dispatches.</li> </ul>"},{"location":"jit/MADHYASTHAL/#design","title":"Design","text":""},{"location":"jit/MADHYASTHAL/#intermediate-representation","title":"Intermediate Representation","text":"<p>Madhyasthal uses its own IR that is sometimes called MIR (not to be confused with Mirage IR). It is a two-address-code IR that is fully in-memory by design, in contrast to the bytecode which originally was very wasteful.</p>"},{"location":"jit/MADHYASTHAL/#lowering","title":"Lowering","text":"<p>Madhyasthal's lowering mechanism works by condensing certain multi-op bytecode patterns into singular operations when possible. These pattern matching routines can be found at <code>src/bali/runtime/compiler/madhyasthal/lowering.nim</code>.</p> <p>When such patterns cannot be matched, it emits the MIR-equivalent of the bytecode instruction, which is generally fairly close to the bytecode's op name.</p>"},{"location":"jit/MADHYASTHAL/#optimizations","title":"Optimizations","text":"<p>Currently, Madhyasthal supports the following optimizations:</p> <ul> <li>Naive dead-code-elimination</li> <li>Algebraic simplification</li> <li>Naive escape analysis (Disabled by default as no pass uses its information)</li> <li>Copy elimination</li> </ul> <p>More optimizations will gradually be added to it. Madhyasthal uses a pipeline system to let the runtime efficiently choose which optimizations should be enabled, and which shouldn't.</p>"},{"location":"jit/MADHYASTHAL/#code-generation","title":"Code Generation","text":"<p>After the pipeline optimizes the IR, it is then sent off to the midtier JIT's actual compiler: the mechanism that converts MIR to x86-64 code. This works fairly similarly to how the baseline JIT emits x86-64 code, the only difference being that the midtier compiler works on Madhyasthal's IR, not the VM's bytecode structures.</p>"}]}